---
title: 쉽게 풀어 쓴 Spring Security 기본 개념
description: Spring Boot를 기반한 Spring Security의 작동 방식을 알아봅니다.
image: '/images/series/spring-security/1-basic-concepts/cover.png'
tags:
  - kotlin
  - spring boot
  - spring security
  - servlet
date: 2024-09-23 16:42:42
isDraft: true
isFeatured: true
---

> **해당 문서와 관련된 코드는 <a style={{color: "grey"}} href="https://github.com/nfl1ryxditimo12/spring-templates/" target="\_blank" rel="noopener noreferrer">링크</a>를 참고해주세요.**
>
> **Spring Security 시리즈는 아래 버전을 기준으로 작성되었습니다.**
>
> - jdk: corretto-21
> - spring boot: 3.3.x <a style={{color: "grey"}} href="https://spring.io/projects/spring-boot#support" target="\_blank" rel="noopener noreferrer">[support]</a>
> - spring security: 6.3.x <a style={{color: "grey"}} href="https://spring.io/projects/spring-security#support" target="\_blank" rel="noopener noreferrer">[support]</a>

---

> ## 글을 시작하며

Spring Security에서 인증, 인가 등 보안 관련 기능을 처리하기 위해 내부적인 작동이 어떻게 이뤄질까요?

이번 글에서는 Servlet 환경을 기준으로 한 Spring Security의 Filtering에 대해 알아보겠습니다.

스프링이 아닌 스프링 부트를 기반으로 하여 많은 부분이 생략되어 있을 수 있습니다.

<br />

## 1. 스프링의 HTTP 통신 과정

---

Spring Security를 설명하기 앞서, 스프링의 HTTP 통신 과정을 간단히 알아보겠습니다.

![Servlet 구조](/images/series/spring-security/1-basic-concepts/servlet-structure.png)

스프링은 HTTP 통신을 위해 서블릿이라는 기술을 사용합니다.
이 포스팅에서 서블릿은 웹 어플리케이션을 개발하며 HTTP 통신을 보다 쉽게 할 수 있게 만들어진 기능이라고 보시면 이해에 도움이 될 것 같습니다. HTTP 메세지를 직접 파싱하거나, TCP 소켓을 관리하는 등의 수고를 덜어주는 존재이기 때문이죠 😏

위 사진의 Web Context가 서블릿 영역으로, 클라이언트 요청을 받으면 HTTP 서블릿(DispatcherServlet)을 이용해 Spring Context로 HTTP 요청을 전달합니다. 이후 Spring Context에서 비즈니스 로직을 통해 요청에 맞는 응답을 내려주게 됩니다.

그리고 요청이 Spring Context로 전달되기 전, **Filter** 레이어가 존재합니다. Filter는 서블릿 영역에 포함되어 HTTP 요청 전달 전/후로 공통된 작업을 수행할 수 있습니다. 이 글에서 시사하려는 Spring Security가 동작하는 레이어이기도 합니다.

<br />

#### 스프링이 HTTP 요청을 처리하는 순서를 요약하면 다음과 같습니다.

1. 클라이언트가 HTTP 요청을 서버에 전송합니다.
2. Servlet Container에서 요청을 읽어 HttpServletRequest, HttpServletResponse 객체를 생성합니다.
3. Spring Context에 데이터를 전달하기 전, Servlet FilterChain을 실행합니다.
   - FilterChain은 빈으로 등록된 Filter들을 순차적으로 실행합니다.
4. 이후 요청을 DispatcherServlet으로 전달합니다. 이 부분 부터 Spring Context로 전환됩니다.
5. DispatcherServlet은 URL 기반 라우팅을 통해 Controller로 요청을 전달합니다.
6. 비즈니스 로직 수행 후, 생성된 HTTP 응답을 Servlet Container를 통해 클라이언트로 응답합니다.

<br />

#### 알아두면 좋은 내용

- 서블릿과 서블릿 컨테이너는 추상적인 개념으로, 스프링에서 HTTP 통신을 쉽게 돕는 역할을 합니다. 서블릿 컨테이너는 서블릿의 생명주기를 관리하며, HTTP 요청을 받아 서블릿으로 전달합니다.
- 서블릿의 구현체는 HttpServlet이며, 이를 상속한 DispatcherServlet이라는 자바 클래스가 주로 사용됩니다. DispatcherServlet은 url 기반 라우팅을 지원하여 요청을 적절한 Controller로 전달합니다.
- 서블릿 컨테이너의 구현체로는 톰캣, 제티 등이 존재하며, TCP 소켓 통신이나 HTTP 메세지를 파싱하여 HttpServletRequest, HttpServletResponse 객체로 변환하는 과정을 담당합니다.

<br />

## 2. FilterChain으로 알아보는 스프링 시큐리티의 작동 방식

---

### FilterChain이란?

> 단일 HTTP 요청을 처리하기 위한 레이어로 여러개의 Filter들이 사슬처럼 연결되어 있으며 순서에 따라 동기적으로 작동합니다. 비즈니스 로직 전후로 공통된 작업을 수행하거나, 요청을 가로채어 특정 작업을 수행하는 등 다양한 용도로 사용됩니다.
>
> Filter는 Spring의 `@Order` 어노테이션이나 `Orderd` 인터페이스 등 여러 방법을 이용해 FilterChain의 순서를 지정할 수 있으며, URL 패턴을 이용해 특정 요청에만 적용이 가능하기도 합니다.

<br />

### FilterChain의 구조

스프링 시큐리티는 서블릿 Filter를 기반으로 동작하기 때문에, 일반적인 FilterChain의 과정을 함께 살펴보면 이해가 쉬워집니다. 아래 이미지는 [스프링 HTTP 통신 과정](#스프링이-http-요청을-처리하는-순서를-요약하면-다음과-같습니다)의 3번째 단계인 FilterChain의 세부 과정을 나타낸 것입니다.

![FilterChain 구조](/images/series/spring-security/1-basic-concepts/filterchain.png)

Servlet Container의 HTTP 요청 전처리 과정이 완료된 후 FilterChain이 실행됩니다. FilterChain은 미리 정의된 Filter들을 순차적으로 실행합니다. Filter는 보통 인코딩, 데이터 파싱, 로깅 등 간단한 목적으로 사용된다고 볼 수 있습니다.

여기서 눈여겨볼 점은 **DelegatingFilterProxy**라는 Filter 입니다. 이는 서블릿과 스프링의 생명주기 차이를 방지하기 위한 장치로, DelegatingFilterProxy가 호출되는 시점에 스프링 Bean에 등록된 Filter 구현체를 실행합니다. 이러한 Lazy Loading 전략으로 스프링 Bean에 안전한 접근을 가능하게 합니다.
<span style={{color: "grey"}}>_스프링 부트는 생명주기 제어가 가능해, DelegatingFilterProxy를 사용하지 않고도 스프링 Bean에 접근이 가능합니다._</span>

아래 `Pseudo Code`는 DelegatingFilterProxy의 호출 시점 일부입니다.

```java
protected Filter initDelegate(WebApplicationContext wac) throws ServletException {
    // 스프링 시큐리티의 경우, targetBeanName은 `securityFilterChain`
    String targetBeanName = this.getTargetBeanName();
    // targetBeanName과 일치하는 이름을 가진 Filter Bean을 찾음
    Filter delegate = (Filter)wac.getBean(targetBeanName, Filter.class);

    // 반환 이후 `delegate.doFilter()`를 통해 Filter 구현체를 실행
    return delegate
}
```

이를 통해 DI와 같은 스프링 기술을 사용할 수 있어, 스프링 시큐리티는 유연하고 확장성있는 보안 설정이 가능하며 서비스의 다양한 요구사항을 충족시킬 수 있습니다.

<br />

### Spring Security의 FilterChain

![SecurityFilterChain](/images/series/spring-security/1-basic-concepts/securityfilterchain.png)

SpringFilterChain도 FilterChain과 작동 방식은 비슷합니다.



<br />

## 3. 스프링 시큐리티를 이용한 보안 처리

---

<br />

## 4. 스프링 시큐리티를 잘 활용하기 위한 방법

---

<br />
